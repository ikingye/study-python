<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on Python 学习笔记</title>
    <link>https://ikingye.github.io/study-python/</link>
    <description>Recent content in 首页 on Python 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>包管理</title>
      <link>https://ikingye.github.io/study-python/docs/basic/package/manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/package/manage/</guid>
      <description>Python 包管理 pip 加速 修改 ~/.pip/pip.conf
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn </description>
    </item>
    
    <item>
      <title>基础</title>
      <link>https://ikingye.github.io/study-python/docs/appendix/interview/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/appendix/interview/basic/</guid>
      <description>基础面试题 </description>
    </item>
    
    <item>
      <title>版本管理</title>
      <link>https://ikingye.github.io/study-python/docs/basic/version/manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/version/manage/</guid>
      <description>Python 版本管理 pyenv pyenv 加速 在 .zshrc 添加
function pyenvinstall { wget -c https://npm.taobao.org/mirrors/python/$@/Python-$@.tar.xz -P ~/.pyenv/cache/ pyenv install $@ } 执行 zsh 使配置生效， 之后即可这样安装： pyenvinstall 3.8.2
pyenv 基础命令 pyenv global 3.8.2 2.7.17 set by ~/.pyenv/version
3.8.2 2.7.17 pyenv shell 3.8.2 2.7.17 set by PYENV_VERSION environment variable
$ echo $PYENV_VERSION 3.8.2:2.7.17 </description>
    </item>
    
    <item>
      <title>进阶</title>
      <link>https://ikingye.github.io/study-python/docs/appendix/interview/advanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/appendix/interview/advanced/</guid>
      <description>进阶面试题 猴子补丁 属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。
为什么叫猴子补丁 属性的运行时替换和猴子也没什么关系，关于猴子补丁的由来网上查到两种说法：
  这个词原来为 Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里 guerilla 发音和 gorllia (猩猩) 相似，再后来就写了 monkey (猴子)。
  还有一种解释是说由于这种方式将原来的代码弄乱了 (messing with it)，在英文里叫 monkeying about (顽皮的)，所以叫做 Monkey Patch。
  猴子补丁的叫法有些莫名其妙，只要和 “模块运行时替换的功能” 对应就行了。
ujson import json import ujson def monkey_patch_json(): json.__name__ = &amp;#39;ujson&amp;#39; json.dumps = ujson.dumps json.loads = ujson.loads monkey_patch_json() 参考：
 Python 猴子补丁 python 面试题精讲 ——monkey patch（猴子补丁）  </description>
    </item>
    
    <item>
      <title>高阶</title>
      <link>https://ikingye.github.io/study-python/docs/appendix/interview/expert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/appendix/interview/expert/</guid>
      <description>高阶面试题 </description>
    </item>
    
    <item>
      <title>百度 Python 编码规范</title>
      <link>https://ikingye.github.io/study-python/docs/basic/practice/spec/baidu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/practice/spec/baidu/</guid>
      <description>百度 Python 编码规范 </description>
    </item>
    
    <item>
      <title>内建函数</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/builtin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/builtin/</guid>
      <description>内建函数 all 判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE
any 判断给定的可迭代参数 iterable 全为 False，则返回 False，如果有一个为 True，则返回 True
元素除了是 0、空、FALSE 外都算 TRUE。
basestring isinstance(obj, basestring) 等价于 isinstance(obj, (str, unicode))
python3 已经没有 basestring 类型，用 str 代替了 basestring  enumerate 将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列，同时列出数据和数据下标
enumerate(sequence, [start=0])
eval 执行一个字符串表达式，并返回表达式的值
eval(&amp;#39;3 * x&amp;#39;) eval(&amp;#39;pow(2,2)&amp;#39;) isinstance 判断一个对象是否是一个已知的类型
isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 pow pow(x, y[, z])
等效于 pow (x, y) % z
staticmethod 静态方法无需实例化，也可以实例化后调用
ord 以一个字符（长度为 1 的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/slice/</guid>
      <description>切片 [start:end:step] 遍历 enumerate a = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;] # index &amp;amp; value for i in xrange(len(a)): print i, a[i] # iterate with index for i, el in enumerate(a): print i, el # i 从 1 开始 for i, el in enumerate(a, 1): print i, el step 为负数 最后一个字符到下标是 -1，即从右到左，是从 -1 开始，然后 -1、-2、-3、-4、-5
字符串反转 letter[::-1] 为什么 s[:-1:-1] 是空 只需要记住，s[start:end:step] 就行，包括 start，不包括 end， 所以，如果要实现：去掉最后一个元素，然后再倒序，应该是：
 倒数第二个作为 start，end 默认，step 是 -1 也就是：s[-2::-1]  s[i:j:k]   If i or j is negative, the index is relative to the end of sequence s:</description>
    </item>
    
    <item>
      <title>协程</title>
      <link>https://ikingye.github.io/study-python/docs/basic/practice/coroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/practice/coroutine/</guid>
      <description>Python 协程  执行效率高  子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了    因为协程是一个线程执行，那怎么利用多核 CPU 呢？ 最简单的方法是多进程 + 协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
子程序就是协程的一种特例 Donald Knuth 的一句话总结协程的特点：
“子程序就是协程的一种特例。”
gevent  Python 通过 yield 提供了对协程的基本支持，但是不完全。而第三方的 gevent 为 Python 提供了比较完善的协程支持。
gevent 是第三方库，通过 greenlet 实现协程，其基本思想是：
当一个 greenlet 遇到 IO 操作时，比如访问网络，就自动切换到其他的 greenlet，等到 IO 操作完成，再在适当的时候切换回来继续执行。由于 IO 操作非常耗时，经常使程序处于等待状态，有了 gevent 为我们自动切换协程，就保证总有 greenlet 在运行，而不是等待 IO。
由于切换是在 IO 操作时自动完成，所以 gevent 需要修改 Python 自带的一些标准库，这一过程在启动时通过 monkey patch 完成：
from gevent import monkey; monkey.patch_socket() import gevent def f(n): for i in range(n): print gevent.</description>
    </item>
    
    <item>
      <title>字典</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/dict/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/dict/</guid>
      <description>字典 遍历 for key in d: # For Python 3.x: for key, value in d.items(): # For Python 2.x: for key, value in d.iteritems(): items The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary&amp;rsquo;s (key, value) pairs, which will not reflect changes to the dict that happen after the items() call.
If you want the 2.x behavior in 3.</description>
    </item>
    
    <item>
      <title>生成器</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/generator/</guid>
      <description>生成器 iterable 可迭代的 Everything you can use &amp;ldquo;for&amp;hellip; in&amp;hellip;&amp;rdquo; on is an iterable; lists, strings, files&amp;hellip;
iterable 包括：
 list tuple string dictionary file enumerate object  iterator 迭代器  iter() 函数用来生成迭代器。 iter(object[, sentinel])  object：支持迭代的集合对象 sentinel  如果传递了 sentinel，则 object 必须是一个可调用的对象（如函数），此时 iter 创建了一个迭代器对象 每次调用这个迭代器对象的 __next__() 方法时，都会调用 object      迭代器只能迭代一次
a kind of iterable you can only iterate over once.
generator Generators are iterators, a kind of iterable you can only iterate over once.</description>
    </item>
    
    <item>
      <title>类</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/class/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/class/</guid>
      <description>类 问答 class 后面加不加 object 的区别 python 3 中已经默认就帮你加载了 object 了（即便你没有写上 object）
   python 2.x python 2.x python 3.x python 3.x     不含 object 含 object 不含 object 含 object   __doc__ __doc__ __doc__ __doc__   __module__ __module__ __module__ __module__    __class__ __class__ __class__    __delattr__ __delattr__ __delattr__    __dict__ __dict__ __dict__    __format__ __format__ __format__    __getattribute__ __getattribute__ __getattribute__    __hash__ __hash__ __hash__    __init__ __init__ __init__    __new__ __new__ __new__    __reduce__ __reduce__ __reduce__    __reduce_ex__ __reduce_ex__ __reduce_ex__    __repr__ __repr__ __repr__    __setattr__ __setattr__ __setattr__    __sizeof__ __sizeof__ __sizeof__    __str__ __str__ __str__    __subclasshook__ __subclasshook__ __subclasshook__    __weakref__ __weakref__ __weakref__     __dir__ __dir__     __eq__ __eq__     __ge__ __ge__     __gt__ __gt__     __le__ __le__     __lt__ __lt__     __ne__ __ne__     __init_subclass__ __init_subclass__    init_subclass 类方法 __init_subclass__ 从 3.</description>
    </item>
    
    <item>
      <title>装饰器</title>
      <link>https://ikingye.github.io/study-python/docs/basic/grammar/function/decorator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/grammar/function/decorator/</guid>
      <description>装饰器 函数参数能够接收别的函数，就是高阶函数
decorator 就是一个返回函数的高阶函数
import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*argc, **kw): print(&amp;#39;%s%s()&amp;#39; % (text, func.__name)) return func(*args, **kw) return wrapper return decorator @log(&amp;#39;execute&amp;#39;) def now(): print(&amp;#39;2020-04-26&amp;#39;) </description>
    </item>
    
    <item>
      <title>3.7</title>
      <link>https://ikingye.github.io/study-python/docs/basic/version/3.7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/basic/version/3.7/</guid>
      <description>Python 3.7 安装 依赖 sudo yum install readline readline-devel readline-static -y sudo yum install openssl openssl-devel openssl-static -y sudo yum install sqlite-devel -y sudo yum install bzip2-devel bzip2-libs -y libffi-devel 3.7 版本需要一个新的包 libffi-devel，安装此包之后再次进行编译安装即可。
sudo yum install libffi-devel -y make install 若在安装前移除了 /usr/bin 下 python 的文件链接依赖，此时 yum 无法正常使用，需要自己下载相关软件包安装，为节省读者时间，放上链接
wget http://mirror.centos.org/centos/7/os/x86_64/Packages/libffi-devel-3.0.13-18.el7.x86_64.rpm rpm -ivh libffi-devel-3.0.13-18.el7.x86_64.rpm 安装完成后重新进行 make install，结束后再次配置相关文件的软连接即可。
解读： python3 中有个内置模块叫 ctypes，它是 python3 的外部函数库模块，提供了兼容 C 语言的数据类型，并通过它调用 Linux 系统下的共享库 (Shared library)，此模块需要使用 centos7 系统中外部函数库 (Foreign function library) 的开发链接库 (头文件和链接库)。 由于在 centos7 系统中没有安装外部函数库 (libffi) 的开发链接库软件包，所以在安装 pip 的时候就报了 &amp;ldquo;ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;&amp;rdquo; 的错误。</description>
    </item>
    
    <item>
      <title>关注</title>
      <link>https://ikingye.github.io/study-python/docs/appendix/attention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-python/docs/appendix/attention/</guid>
      <description>关注 twisted/twisted  Event-driven networking engine written in Python. https://www.twistedmatrix.com
gevent/gevent  Coroutine-based concurrency library for Python http://gevent.org</description>
    </item>
    
  </channel>
</rss>