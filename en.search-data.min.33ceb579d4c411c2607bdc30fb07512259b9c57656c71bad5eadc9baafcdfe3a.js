'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/study-python/docs/basic/other/package/manage/',title:"包管理",section:"Package",content:"Python 包管理 #  pip #  加速 #  修改 ~/.pip/pip.conf\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn "}),a.add({id:1,href:'/study-python/docs/basic/other/version/manage/',title:"版本管理",section:"版本",content:"Python 版本管理 #  pyenv #  pyenv 加速 #  在 .zshrc 添加\nfunction pyenvinstall { wget -c https://npm.taobao.org/mirrors/python/$@/Python-$@.tar.xz -P ~/.pyenv/cache/ pyenv install $@ } 执行 zsh 使配置生效， 之后即可这样安装： pyenvinstall 3.8.2\npyenv 基础命令 #  # List all available versions pyenv install -l # 更新 pyenv update brew update \u0026amp;\u0026amp; brew upgrade pyenv pyenv update #  pyenv/pyenv-update git clone https://github.com/pyenv/pyenv-update.git $(pyenv root)/plugins/pyenv-update pyenv update pyenv global 3.8.2 2.7.17 #  set by ~/.pyenv/version\n3.8.2 2.7.17 pyenv shell 3.8.2 2.7.17 #  set by PYENV_VERSION environment variable\n$ echo $PYENV_VERSION 3.8.2:2.7.17  pyenv 优先级 #   pyenv shell  $PYENV_VERSION   pyenv local  .python-version file   pyenv global  ~/.pyenv/version   System Python    "}),a.add({id:2,href:'/study-python/docs/basic/grammar/',title:"1.1 语法",section:"第一部分 基础入门",content:"语法 #  range vs xrange #  range 是直接返回一个保存全量数据的 list, 空间复杂度是 O(n),\n而 xrange 是在遍历中不断生成的，遍历的效率更高，而且空间复杂度是 O(1)\npython3 取消了 xrange，range 就是 xrange  \u0026lt;type \u0026lsquo;xrange\u0026rsquo;\u0026gt; #   iteritems vs viewitems #  \u0026lt;type \u0026lsquo;dict_items\u0026rsquo;\u0026gt; #  \u0026lt;type \u0026lsquo;dictionary-valueiterator\u0026rsquo;\u0026gt; #   变量 #  全局变量 #  a = 3 def func(): print(a) func() 在 Python 中，a=3 定义了全局变量 a，作用域从定义处到代码结束，在 a=3 以下的函数中是可以引用全局变量 a 的。\n但如果要修改函数中与全局变量同名的变量，则函数中的该变量就会变成局部变量， 在修改之前对该变量的引用自然会出现未分配或未定义的错误了。\na = 3 def func(): # 如果确定要引用并修改全局变量必须加上 global 关键字 global a print (a) a=a+1 func()  尾递归 #  Python 解释器不支持尾递归优化\n参考：\n What is tail recursion? What is tail call optimization?   参考 #   Python 语言参考 Python 标准库  "}),a.add({id:3,href:'/study-python/docs/advanced/pattern/',title:"2.1 设计模式",section:"第二部分 进阶实战",content:"Python 设计模式 #  参考 #  faif/python-patterns #  "}),a.add({id:4,href:'/study-python/docs/code/type/',title:"3.1 数据类型",section:"第三部分 源码实现",content:"Python 数据类型 #  "}),a.add({id:5,href:'/study-python/docs/appendix/tutorial/',title:"4.1 教程",section:"第四部分 附录",content:"教程 #  基础 #  satwikkansal/wtfpython #  leisurelicht/wtfpython-cn 一些有趣且鲜为人知的 Python 特性\ngto76/python-cheatsheet #  Comprehensive Python Cheatsheet\n (book)yidao620c/python3-cookbook #  《Python Cookbook》 3rd Edition 翻译\n  进阶 #  jakevdp/PythonDataScienceHandbook #  Python Data Science Handbook: full text in Jupyter Notebooks\n"}),a.add({id:6,href:'/study-python/docs/basic/other/package/common/',title:"常用",section:"Package",content:"常用 Package #  网络 #  twisted/twisted #  Event-driven networking engine written in Python. https://www.twistedmatrix.com\nTwisted Introduction\nThis multi-part series introduces Asynchronous Programming and the Twisted networking framework.\n"}),a.add({id:7,href:'/study-python/docs/basic/std/',title:"1.2 标准库",section:"第一部分 基础入门",content:"Python 标准库 #  "}),a.add({id:8,href:'/study-python/docs/advanced/algs/',title:"2.2 算法实现",section:"第二部分 进阶实战",content:"Python 算法实现 #  "}),a.add({id:9,href:'/study-python/docs/code/keyword/',title:"3.2 关键字",section:"第三部分 源码实现",content:"Python 关键字 #  "}),a.add({id:10,href:'/study-python/docs/appendix/interview/',title:"4.2 面试题",section:"第四部分 附录",content:"面试题 #  参考：\n 如何面试 Python 后端工程师？  基础题 #  数据结构 #  元组是不是真的不可变？ #  tuple 的每个元素，指向永远不变。\n要创建一个内容也不变的 tuple 怎么做？\n必须保证 tuple 的每一个元素本身也不能变。\n# “可变的” tuple： \u0026gt;\u0026gt;\u0026gt; t = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; t[2][0] = \u0026#39;X\u0026#39; \u0026gt;\u0026gt;\u0026gt; t[2][1] = \u0026#39;Y\u0026#39; \u0026gt;\u0026gt;\u0026gt; t (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, [\u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;])  迭代器 vs 生成器 #  迭代器 #  把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__()\n\u0026gt;\u0026gt;\u0026gt; list=[1,2,3,4] \u0026gt;\u0026gt;\u0026gt; it = iter(list) # 创建迭代器对象 \u0026gt;\u0026gt;\u0026gt; print (next(it)) # 输出迭代器的下一个元素 1 \u0026gt;\u0026gt;\u0026gt; print (next(it)) 2 \u0026gt;\u0026gt;\u0026gt; 生成器 #  在 Python 中，使用了 yield 的函数被称为生成器（generator）。\n生成器是一个返回迭代器的函数。\npython 中生成器是迭代器的一种，使用 yield 返回值函数，每次调用 yield 会暂停，而可以使用 next () 函数和 send () 函数恢复生成器。\n要创建一个 generator，有很多种方法，第一种方法很简单，只有把一个列表生成式的 [] 中括号改为（）小括号，就创建一个 generator\n#列表生成式 lis = [x*x for x in range(10)] print(lis) #生成器 generator_ex = (x*x for x in range(10)) print(generator_ex) 结果： [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x000002A4CBF9EBA0\u0026gt;  进阶题 #  猴子补丁 #  属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。\n为什么叫猴子补丁 #  属性的运行时替换和猴子也没什么关系，关于猴子补丁的由来网上查到两种说法：\n  这个词原来为 Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里 guerilla 发音和 gorllia (猩猩) 相似，再后来就写了 monkey (猴子)。\n  还有一种解释是说由于这种方式将原来的代码弄乱了 (messing with it)，在英文里叫 monkeying about (顽皮的)，所以叫做 Monkey Patch。\n  猴子补丁的叫法有些莫名其妙，只要和 “模块运行时替换的功能” 对应就行了。\nujson #  import json import ujson def monkey_patch_json(): json.__name__ = \u0026#39;ujson\u0026#39; json.dumps = ujson.dumps json.loads = ujson.loads monkey_patch_json() 参考：\n Python 猴子补丁 python 面试题精讲 ——monkey patch（猴子补丁）  "}),a.add({id:11,href:'/study-python/docs/basic/grammar/builtin/',title:"内建函数",section:"1.1 语法",content:"内建函数 #  all #  判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE\nany #  判断给定的可迭代参数 iterable 全为 False，则返回 False，如果有一个为 True，则返回 True\n元素除了是 0、空、FALSE 外都算 TRUE。\nbasestring #  isinstance(obj, basestring) 等价于 isinstance(obj, (str, unicode))\npython3 已经没有 basestring 类型，用 str 代替了 basestring  enumerate #  将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列，同时列出数据和数据下标\nenumerate(sequence, [start=0])\neval #  执行一个字符串表达式，并返回表达式的值\neval(\u0026#39;3 * x\u0026#39;) eval(\u0026#39;pow(2,2)\u0026#39;) isinstance #  判断一个对象是否是一个已知的类型\nisinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 pow #  pow(x, y[, z])\n等效于 pow (x, y) % z\nstaticmethod #  静态方法无需实例化，也可以实例化后调用\nord #  以一个字符（长度为 1 的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，\n如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。\nord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）或 unichr() 函数（对于 Unicode 对象）的配对函数\n "}),a.add({id:12,href:'/study-python/docs/basic/grammar/function/',title:"函数",section:"1.1 语法",content:"函数 #  __init__ vs __new__ #  __new__ 最先被调用，通常用于控制生成一个新实例的过程。 它是类级别的方法。\n__new__ 方法主要是当你继承一些不可变的 class 时 (比如 int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的 metaclass。\n__init__ 方法通常用在初始化一个类实例的时候调用。\nclass PositiveInteger(int): def __init__(self, value): super(PositiveInteger, self).__init__(self, abs(value)) i = PositiveInteger(-3) print i # -3 # 对于 int 这种 不可变的对象，我们只有重载它的 __new__ 方法才能起到自定义的作用 class PositiveInteger(int): def __new__(cls, value): return super(PositiveInteger, cls).__new__(cls, abs(value)) i = PositiveInteger(-3) print i # 3 用 __new__ 来实现单例 #  class Singleton(object): def __new__(cls): # 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象 if not hasattr(cls, \u0026#39;instance\u0026#39;): cls.instance = super(Singleton, cls).__new__(cls) return cls.instance obj1 = Singleton() obj2 = Singleton() obj1.attr1 = \u0026#39;value1\u0026#39; print obj1.attr1, obj2.attr1 # value1 value1 print obj1 is obj2 # True metaclass vs __new__ #   Partial function 偏函数 #  functools.partial 的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数\n当函数的参数个数太多，需要简化时，使用 functools.partial 可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n柯里化 Currying #  柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数 (最初函数的第一个参数) 的函数，并且返回接受余下的参数且返回结果的新函数\n柯里化（Currying）是由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n从纯粹的语义上，curry 化就是 lambda 表达式的一个糖\n参考：\n 柯里化在工程中有什么好处？ 柯里化对函数式编程有何意义？  "}),a.add({id:13,href:'/study-python/docs/basic/grammar/slice/',title:"切片",section:"1.1 语法",content:"切片 #  [start:end:step] 遍历 #  enumerate #  a = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;] # index \u0026amp; value for i in xrange(len(a)): print i, a[i] # iterate with index for i, el in enumerate(a): print i, el # i 从 1 开始 for i, el in enumerate(a, 1): print i, el step 为负数 #  最后一个字符到下标是 -1，即从右到左，是从 -1 开始，然后 -1、-2、-3、-4、-5\n字符串反转 #  letter[::-1] 为什么 s[:-1:-1] 是空 #  只需要记住，s[start:end:step] 就行，包括 start，不包括 end， 所以，如果要实现：去掉最后一个元素，然后再倒序，应该是：\n 倒数第二个作为 start，end 默认，step 是 -1 也就是：s[-2::-1]  s[i:j:k]   If i or j is negative, the index is relative to the end of sequence s:\n len(s) + i or len(s) + j is substituted. But note that -0 is still 0.    The slice of s from i to j with step k\n is defined as the sequence of items with index x = i + n*k such that 0 \u0026lt;= n \u0026lt; (j-i)/k.    the indices are i, i+k, i+2k, i+3k and so on,\n stopping when j is reached (but never including j).    When k is positive, i and j are reduced to len(s) if they are greater.\n  When k is negative, i and j are reduced to len(s) - 1 if they are greater.\n  If i or j are omitted or None, they become “end” values (which end depends on the sign of k).\n  k cannot be zero.\n If k is None, it is treated like 1.    s[:]\n 等同于 s[::] 等同于 s[None:None:None] 等同于 s[0:len(s):1]    s[::-1]\n 等同于 s[None:None:-1] 等同于 s[len(s)-1:-len(s)-1:-1]  包括 start，所以 start 从 len(s)-1 开始, 就是 s[-1] 不包括 end, 所以 end 到 -len(s)-1, 实际上就是到 -len(s), 也就是 s[0]      s[:-1:-1]\n 等同于 s[len(s)-1:-1:-1] 等同于 s[len(s)-1:len(s)-1:-1]    参考：\n Python list error: [::-1] step on [:-1] slice Common Sequence Operations   sequence 乘法 #   s * n 或 n * s  equivalent to adding s to itself n times  items in the sequence s are not copied they are referenced multiple times   Values of n less than 0 are treated as 0  which yields an empty sequence of the same type as s      \u0026gt;\u0026gt;\u0026gt; lists = [[]] * 3 \u0026gt;\u0026gt;\u0026gt; lists [[], [], []] \u0026gt;\u0026gt;\u0026gt; lists[0].append(3) \u0026gt;\u0026gt;\u0026gt; lists [[3], [3], [3]] "}),a.add({id:14,href:'/study-python/docs/basic/other/coroutine/',title:"协程",section:"1.4 其他",content:"Python 协程 #   执行效率高  子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了    因为协程是一个线程执行，那怎么利用多核 CPU 呢？ 最简单的方法是多进程 + 协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。\n子程序就是协程的一种特例 #  Donald Knuth 的一句话总结协程的特点：\n“子程序就是协程的一种特例。”\ngevent #  Python 通过 yield 提供了对协程的基本支持，但是不完全。而第三方的 gevent 为 Python 提供了比较完善的协程支持。\ngevent 是第三方库，通过 greenlet 实现协程，其基本思想是：\n当一个 greenlet 遇到 IO 操作时，比如访问网络，就自动切换到其他的 greenlet，等到 IO 操作完成，再在适当的时候切换回来继续执行。由于 IO 操作非常耗时，经常使程序处于等待状态，有了 gevent 为我们自动切换协程，就保证总有 greenlet 在运行，而不是等待 IO。\n由于切换是在 IO 操作时自动完成，所以 gevent 需要修改 Python 自带的一些标准库，这一过程在启动时通过 monkey patch 完成：\nfrom gevent import monkey; monkey.patch_socket() import gevent def f(n): for i in range(n): print gevent.getcurrent(), i g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 参考：\n Python 协程   "}),a.add({id:15,href:'/study-python/docs/basic/grammar/dict/',title:"字典",section:"1.1 语法",content:"字典 #  遍历 #  for key in d: # For Python 3.x: for key, value in d.items(): # For Python 2.x: for key, value in d.iteritems(): items #  The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary\u0026rsquo;s (key, value) pairs, which will not reflect changes to the dict that happen after the items() call.\nIf you want the 2.x behavior in 3.x, you can call list(d.items())\niteritems #  返回 iterator 对象\ndictionary-itemiterator object\npython3 没有 iteritems  viewitems #  Summary (with a little backstory): view* methods are a live view into the data (that will update as it updates), whereas iter* and just-plain * are more like snapshots.\npython3 没有 viewitems，items 等同于 python2 的 viewitems  The objects returned by dict.viewkeys(), dict.viewvalues() and dict.viewitems() are view objects. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.\n参考：\n In Python 2, what are the performance trade-offs for viewvalues()/viewitems() over itervalues()/iteritems()?  "}),a.add({id:16,href:'/study-python/docs/basic/other/version/',title:"版本",section:"1.4 其他",content:"Python 版本 #   3 #  3.9 #  3.9.0 (2020-10-05) #   3.8 #  3.8.6 (2020-09-24) #  3.8.5 (2020-07-20) #  3.8.0 (2019-10-14) #   3.7 #  3.7.9 (2020-08-17) #  3.7.0 (2018-06-27) #    2 #  2.7 #  2020-01-01 已经废弃\n2.7.18 (2020-04-20) #  2.7.0 #   2.6 #  2.6.9 (2013-10-29) #  2.6.0 (2008-10-02) #  "}),a.add({id:17,href:'/study-python/docs/basic/grammar/generator/',title:"生成器",section:"1.1 语法",content:"生成器 #  iterable 可迭代的 #  Everything you can use \u0026ldquo;for\u0026hellip; in\u0026hellip;\u0026rdquo; on is an iterable; lists, strings, files\u0026hellip;\niterable 包括：\n list tuple string dictionary file enumerate object  iterator 迭代器 #   iter() 函数用来生成迭代器。 iter(object[, sentinel])  object：支持迭代的集合对象 sentinel  如果传递了 sentinel，则 object 必须是一个可调用的对象（如函数），此时 iter 创建了一个迭代器对象 每次调用这个迭代器对象的 __next__() 方法时，都会调用 object      迭代器只能迭代一次\na kind of iterable you can only iterate over once.\ngenerator #  Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.\n带有 yield 的函数在 Python 中被称之为 generator（生成器）函数\nyield #   执行带有 yield 的函数返回一个 generator（生成器） next(g) 开始执行这个 generator，执行完 yield 语句，就返回 第二次 next(g) 从 yield 语句后开始执行（比如 yield 语句的赋值操作），再遇到 yield 语句也是一样，执行完就返回  next #  send #  close #  参考：\n python 中 yield 的用法详解 —— 最简单，最清晰的解释 What does the “yield” keyword do? python generator “send” function purpose?  "}),a.add({id:18,href:'/study-python/docs/basic/grammar/class/',title:"类",section:"1.1 语法",content:"类 #  问答 #  class 后面加不加 object 的区别 #  python 3 中已经默认就帮你加载了 object 了（即便你没有写上 object）\n   python 2.x python 2.x python 3.x python 3.x     不含 object 含 object 不含 object 含 object   __doc__ __doc__ __doc__ __doc__   __module__ __module__ __module__ __module__    __class__ __class__ __class__    __delattr__ __delattr__ __delattr__    __dict__ __dict__ __dict__    __format__ __format__ __format__    __getattribute__ __getattribute__ __getattribute__    __hash__ __hash__ __hash__    __init__ __init__ __init__    __new__ __new__ __new__    __reduce__ __reduce__ __reduce__    __reduce_ex__ __reduce_ex__ __reduce_ex__    __repr__ __repr__ __repr__    __setattr__ __setattr__ __setattr__    __sizeof__ __sizeof__ __sizeof__    __str__ __str__ __str__    __subclasshook__ __subclasshook__ __subclasshook__    __weakref__ __weakref__ __weakref__     __dir__ __dir__     __eq__ __eq__     __ge__ __ge__     __gt__ __gt__     __le__ __le__     __lt__ __lt__     __ne__ __ne__     __init_subclass__ __init_subclass__    init_subclass #  类方法 __init_subclass__ 从 3.6 （whatsnew3.6） 引入，作用是可以在不使用元类的情况下改变子类的行为。严格来说它不属于元类编程，但也能达到编辑其他类的一种手段。\n参考：\n 理解 Python 中的 init_subclass  "}),a.add({id:19,href:'/study-python/docs/basic/grammar/function/decorator/',title:"装饰器",section:"函数",content:"装饰器 #  函数参数能够接收别的函数，就是高阶函数\ndecorator 就是一个返回函数的高阶函数\nimport functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*argc, **kw): print(\u0026#39;%s%s()\u0026#39; % (text, func.__name)) return func(*args, **kw) return wrapper return decorator @log(\u0026#39;execute\u0026#39;) def now(): print(\u0026#39;2020-04-26\u0026#39;) "}),a.add({id:20,href:'/study-python/docs/basic/spec/',title:"1.3 编程规范",section:"第一部分 基础入门",content:"编程规范 #   Google Python Style Guide  Python 风格指南    "}),a.add({id:21,href:'/study-python/docs/advanced/pkg/',title:"2.3 常用库",section:"第二部分 进阶实战",content:"Python 常用库 #  log #  rochacbruno/dynaconf #  Configuration Management for Python https://dynaconf.com/\n "}),a.add({id:22,href:'/study-python/docs/code/runtime/',title:"3.3 运行时",section:"第三部分 源码实现",content:"Python 运行时 #  "}),a.add({id:23,href:'/study-python/docs/appendix/attention/',title:"4.3 关注项目",section:"第四部分 附录",content:"关注项目 #  Web #  pallets/flask #  The Python micro framework for building web applications.\ndjango/django #  The Web framework for perfectionists with deadlines.\ntornadoweb/tornado #  Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed.\nencode/django-rest-framework #  Web APIs for Django\n Machine Learning #  scikit-learn/scikit-learn #  scikit-learn: machine learning in Python\n Deep Learning #  keras-team/keras #  Deep Learning for humans\n 其他 #  twisted/twisted #  Event-driven networking engine written in Python. https://www.twistedmatrix.com\ngevent/gevent #  Coroutine-based concurrency library for Python http://gevent.org\npython/cpython #  The Python programming language\npandas-dev/pandas #  scrapy/scrapy #  Scrapy, a fast high-level web crawling \u0026amp; scraping framework for Python.\njakubroztocil/httpie #  prompt-toolkit/python-prompt-toolkit #  Library for building powerful interactive command line applications in Python https://python-prompt-toolkit.readthedocs.io/en/master/\n"}),a.add({id:24,href:'/study-python/docs/basic/other/',title:"1.4 其他",section:"第一部分 基础入门",content:"其他 #  "}),a.add({id:25,href:'/study-python/docs/advanced/snippet/',title:"2.4 代码片段",section:"第二部分 进阶实战",content:"Python 代码片段 #  "}),a.add({id:26,href:'/study-python/docs/advanced/test/',title:"2.5 测试",section:"第二部分 进阶实战",content:"Python 测试 #  "}),a.add({id:27,href:'/study-python/docs/basic/other/version/3.7/',title:"3.7",section:"版本",content:"Python 3.7 #  安装 #  依赖 #  sudo yum install readline readline-devel readline-static -y sudo yum install openssl openssl-devel openssl-static -y sudo yum install sqlite-devel -y sudo yum install bzip2-devel bzip2-libs -y libffi-devel #  3.7 版本需要一个新的包 libffi-devel，安装此包之后再次进行编译安装即可。\nsudo yum install libffi-devel -y make install 若在安装前移除了 /usr/bin 下 python 的文件链接依赖，此时 yum 无法正常使用，需要自己下载相关软件包安装，为节省读者时间，放上链接\nwget http://mirror.centos.org/centos/7/os/x86_64/Packages/libffi-devel-3.0.13-18.el7.x86_64.rpm rpm -ivh libffi-devel-3.0.13-18.el7.x86_64.rpm 安装完成后重新进行 make install，结束后再次配置相关文件的软连接即可。\n解读： python3 中有个内置模块叫 ctypes，它是 python3 的外部函数库模块，提供了兼容 C 语言的数据类型，并通过它调用 Linux 系统下的共享库 (Shared library)，此模块需要使用 centos7 系统中外部函数库 (Foreign function library) 的开发链接库 (头文件和链接库)。 由于在 centos7 系统中没有安装外部函数库 (libffi) 的开发链接库软件包，所以在安装 pip 的时候就报了 \u0026ldquo;ModuleNotFoundError: No module named \u0026lsquo;_ctypes\u0026rsquo;\u0026rdquo; 的错误。\n"}),a.add({id:28,href:'/study-python/docs/basic/other/package/',title:"Package",section:"1.4 其他",content:"Package #  "}),a.add({id:29,href:'/study-python/docs/advanced/prof/',title:"2.6 性能",section:"第二部分 进阶实战",content:"Python 性能 #  "}),a.add({id:30,href:'/study-python/docs/basic/other/anaconda/',title:"Anaconda",section:"1.4 其他",content:"Anaconda #  Anaconda 是一个免费开源 的 Python 和 R 语言的发行版本，用于计算科学（数据科学、机器学习、大数据处理和预测分析），Anaconda 致力于简化包管理和部署。\nAnaconda 的包使用软件包管理系统 Conda 进行管理。\n"}),a.add({id:31,href:'/study-python/docs/advanced/frame/',title:"2.7 框架",section:"第二部分 进阶实战",content:"Python 框架 #  "})})()